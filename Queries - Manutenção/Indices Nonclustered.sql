/*=================================================
	Descrição:
		Localizar indices NONCLUSTERED
===================================================*/

SELECT O.NAME, INDEXNAME=I.NAME, I.INDEX_ID 
, READS=USER_SEEKS + USER_SCANS + USER_LOOKUPS 
, WRITES = USER_UPDATES 
, ROWS = (SELECT SUM(P.ROWS) FROM SYS.PARTITIONS P WHERE P.INDEX_ID = S.INDEX_ID AND S.OBJECT_ID = P.OBJECT_ID)
, CASE
 WHEN S.USER_UPDATES < 1 THEN 100
 ELSE 1.00 * (S.USER_SEEKS + S.USER_SCANS + S.USER_LOOKUPS) / S.USER_UPDATES
 END AS READS_PER_WRITE
, 'DROP INDEX ' + QUOTENAME(I.NAME) 
+ ' ON ' + QUOTENAME(C.NAME) + '.' + QUOTENAME(OBJECT_NAME(S.OBJECT_ID)) AS 'DROP STATEMENT'
FROM SYS.DM_DB_INDEX_USAGE_STATS S 
INNER JOIN SYS.INDEXES I ON I.INDEX_ID = S.INDEX_ID AND S.OBJECT_ID = I.OBJECT_ID 
INNER JOIN SYS.OBJECTS O ON S.OBJECT_ID = O.OBJECT_ID
INNER JOIN SYS.SCHEMAS C ON O.SCHEMA_ID = C.SCHEMA_ID
WHERE OBJECTPROPERTY(S.OBJECT_ID,'ISUSERTABLE') = 1
AND S.DATABASE_ID = DB_ID() 
AND I.TYPE_DESC = 'NONCLUSTERED'
AND I.IS_PRIMARY_KEY = 0
AND I.IS_UNIQUE_CONSTRAINT = 0
AND (SELECT SUM(P.ROWS) FROM SYS.PARTITIONS P WHERE P.INDEX_ID = S.INDEX_ID AND S.OBJECT_ID = P.OBJECT_ID) > 10000
ORDER BY READS;